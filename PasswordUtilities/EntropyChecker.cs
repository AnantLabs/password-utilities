// Copyright (c) 2013 Mark Pearce
// http://opensource.org/licenses/MIT

using System;
using System.Globalization;
using System.Collections.Generic;

namespace PasswordUtilities
{
	/// <summary>
	/// This class estimates the information entropy and
	/// strength of a specific password and/or password hash.
	/// </summary>
	internal sealed class EntropyChecker
	{
		// The symbol types used within the password - these are used to make an educated 
		// guess about the password entropy when we don't know the password policy.
        private const string ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
        private const string ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        private const string ASCII_NUMERIC = "0123456789";
        private const string ASCII_OTHER = @"| £""()[]{}<>!;:,.'?*$-+_&=%/\^~#@";
        // This is a pure guess. If we don't know the password policy, there's no way 
		// we can know what range of non-ASCII symbols was used to generate the password.
		private const int NON_ASCII_LENGTH = 100;
        // Collection of above character sets used to analyse password without policy.
        private static readonly Dictionary<String, CharacterSet> CHARACTER_SETS = new Dictionary<String, CharacterSet>();

        // The entry point (in bits of entropy) for each 
        // of the password strength ranges.
        private const double ADEQUATE_ENTRY_POINT = 30.0;
        private const double STRONG_ENTRY_POINT = 60.0;
        private const double VERY_STRONG_ENTRY_POINT = 80.0;

		// Entropy calculator for a password generated by a human.
		// This applies a NIST formula based solely on the password length.
		private readonly double[] NIST_HUMAN_ENTROPY = {0,4,6,8,10,12,14,16,18,19.5,21,22.5,24,25.5,27,28.5,30,31.5,33,34.5,36};
		private readonly int NIST_CUTOFF;
		private readonly double NIST_HIGH;

		// Private representation of public property.
		private double m_PasswordEntropy;

		/// <summary>
		/// Default constructor.
		/// </summary>
		public EntropyChecker()
		{
			// NIST formula constants.
			NIST_CUTOFF = NIST_HUMAN_ENTROPY.Length - 1;
			NIST_HIGH = NIST_HUMAN_ENTROPY[NIST_CUTOFF];

            if (CHARACTER_SETS.Count == 0)
            {
                CHARACTER_SETS.Add("AL", new CharacterSet("AL", "ASCII lowercase", ASCII_LOWERCASE));
                CHARACTER_SETS.Add("AU", new CharacterSet("AU", "ASCII uppercase", ASCII_UPPERCASE));
                CHARACTER_SETS.Add("AN", new CharacterSet("AN", "ASCII numeric", ASCII_NUMERIC));
                CHARACTER_SETS.Add("AO", new CharacterSet("AO", "ASCII other", ASCII_OTHER));
            }
		}

		/// <summary>
		/// Specified password as a Unicode string.
		/// </summary>
		public string Password { get; private set; }

		/// <summary>
		/// The password's estimated entropy in bits to 3 decimal places. 
		/// </summary>
		public double PasswordEntropy
		{
			get { return Math.Round(m_PasswordEntropy, 3); }
			private set { m_PasswordEntropy = value; }
		}

		/// <summary>
		/// The password's estimated strength based on its entropy. 
		/// </summary>
		/// <remarks>
		/// This is a bit of a guesstimate - I can't find an accurate formula.
		/// In 1998, the EFF cracked a 56-bit key in 56 hours using specialised FPGA hardware.
		/// In 2002, distributed.net cracked a 64-bit key in 4 years, 9 months, and 23 days.
		/// In August 2010, distributed.net estimated that cracking a 72-bit key using 
		/// current hardware would take about 48,712 days or 133.5 years.
		/// NIST recommends 80 bits for the most secure passwords.
		/// 256 bits will never be broken by any combination of digital computers.
		/// For more details, see http://en.wikipedia.org/wiki/Password_strength
		/// </remarks>
		public PasswordStrength PasswordEstimatedStrength
		{
			get
			{
				if (this.PasswordEntropy < ADEQUATE_ENTRY_POINT)
				{
					return PasswordStrength.Weak;
				}
				else if (this.PasswordEntropy < STRONG_ENTRY_POINT)
				{
					return PasswordStrength.Adequate;
				}
				else if (this.PasswordEntropy < VERY_STRONG_ENTRY_POINT)
				{
					return PasswordStrength.Strong;
				}
				else
				{
					return PasswordStrength.VeryStrong;
				}
			}
		}

		/// <summary>
		/// Estimates the added entropy added to a password by
		/// password stretching using hash iterations.
		/// </summary>
		/// <param name="numberOfHashIterations">
		/// The number of iterations used to produce the final hash.
		/// </param>
		/// <returns>
		/// The added entropy in bits. According to Moore's Law, each
		/// extra bit of entropy will take an extra 18 months to
		/// crack the password hash at the same speed as today.
		/// </returns>
		public double HashEntropy(int numberOfHashIterations)
		{
			return Math.Log(numberOfHashIterations, 2);
		}

		/// <summary>
		/// Estimates the entropy of a random password generated
		/// by a machine where the password policy is known.
		/// </summary>
		/// <param name="passwordPolicy">
		/// The policy used to generate the password.
		/// </param>
		/// <param name="passwordLength">
		/// The lenth of the password to be measured.
		/// </param>
		/// <remarks>
		/// Where the password policy is known, we only need the policy
		/// and the password length to calculate the password entropy.
		/// The formula is L * (log N / log 2), where L is the password length 
		/// and N is the policy-defined average number of symbols used to generate 
		/// each password character. 
		/// For more details, see http://en.wikipedia.org/wiki/Password_strength
		/// </remarks>
		/// <returns>
		/// The password's estimated entropy in bits to 3 decimal places. 
		/// </returns>
		public double MachinePasswordPolicyKnown(PasswordPolicy passwordPolicy, int passwordLength)
		{
			this.ValidateParameters(passwordPolicy, passwordLength);
            if (passwordLength == 0)
            {
                this.PasswordEntropy = 0;
            }
            else
            {
                double averageSymbolCount = AverageSymbolsPerCharacter(passwordPolicy, passwordLength);
			    this.PasswordEntropy = passwordLength * Math.Log(averageSymbolCount, 2);
            }
			return this.PasswordEntropy;
		}

        /// <summary>
        /// Estimates the entropy of a random password generated
        /// by a machine where the password policy is unknown.
        /// </summary>
        /// <param name="password">
        /// The password to be measured as a Unicode string.
        /// </param>
        /// <remarks>
        /// Where the password policy is unknown, we analyse the symbols used to
        /// form the password, then make an educated guess about how many symbols
        /// were used to generate each of the password characters.
        /// The formula is L * (log N / log 2), where L is the password length 
        /// and N is the estimated average number of symbols used to generate 
        /// each password character. 
        /// For more details, see http://en.wikipedia.org/wiki/Password_strength
        /// </remarks>
        /// <returns>
        /// The password's estimated entropy in bits to 3 decimal places. 
        /// </returns>
        public double MachinePasswordPolicyUnknown(string password)
        {
            this.ValidateParameters(password);
            this.Password = password;
            if (Password.Length == 0)
            {
                this.PasswordEntropy = 0;
            }
            else
            {
                double averageSymbolCount = AverageSymbolsPerCharacter(password);
                this.PasswordEntropy = password.Length * Math.Log(averageSymbolCount, 2);
            }
            return this.PasswordEntropy;
        }

		/// <summary>
		/// Estimates the entropy of a password generated by a human.
		/// </summary>
		/// <param name="password">
		/// The password to be measured as a Unicode string.
		/// </param>
		/// <remarks>
		/// A password generated by a human is always weaker than a random password.
		/// Users rarely make full use of larger characters sets in forming passwords. 
		/// For example, hacking results obtained from a MySpace phishing scheme in 
		/// 2006 revealed 34,000 passwords. Only 8.3% used mixed case, numbers, and 
		/// symbols. The most common password was "password"!
		/// </remarks>
		/// <returns>
		/// The password's estimated entropy in bits to 3 decimal places. 
		/// This applies a NIST formula based solely on the password length.
		/// </returns>
		public double HumanPassword(string password)
		{
			this.ValidateParameters(password);
			this.Password = password;
			this.PasswordEntropy = this.CalculateHumanEntropy(password.Length);
			return this.PasswordEntropy;
		}

		// Validate parameters of public methods.
		private void ValidateParameters(PasswordPolicy passwordPolicy, int passwordLength)
		{
			if (passwordPolicy == null)
			{
                throw new ArgumentNullException("passwordPolicy", String.Format(CultureInfo.InvariantCulture, "Password policy cannot be null"));
			}
			if (passwordLength < 0)
			{
				throw new ArgumentOutOfRangeException("passwordLength", String.Format(CultureInfo.InvariantCulture, "Password length must be at least zero"));
			}
		}

		// Validate parameters of public methods.
		private void ValidateParameters(string password)
		{
			if (password == null)
			{
                throw new ArgumentNullException("password", String.Format(CultureInfo.InvariantCulture, "Password cannot be null"));
			}
		}

		// Used for a password generated by a human.
		// This applies a NIST formula based solely on the password length.
		private double CalculateHumanEntropy(int passwordLength)
		{
			double bitsOfEntropy = 0;

			if (passwordLength > NIST_CUTOFF)
			{
				// Example: 21-character password = 36 + 21 - 20 = 37 
				bitsOfEntropy = NIST_HIGH + passwordLength - NIST_CUTOFF;
			}
			else
			{
				// Example: 15-character password = NIST_HUMAN_ENTROPY[15] = 28.5
				bitsOfEntropy = NIST_HUMAN_ENTROPY[passwordLength];
			}

			return bitsOfEntropy;
		}

        // Calculate the average number of symbols used to generate 
        // each password character, using the specified password policy.
        private static double AverageSymbolsPerCharacter(PasswordPolicy passwordPolicy, Int32 passwordLength)
        {
            double symbolCount = 0;

            // First calculate minimum number of symbols.
            foreach (CharacterSet characterSet in passwordPolicy.AllowedCharacterSets)
            {
                symbolCount += characterSet.MinimumNumberOfCharacters * characterSet.Characters.Length;
            }

            // All remaining symbols are taken from the full range allowed.
            symbolCount += (passwordLength - passwordPolicy.MinimumNumberOfSymbols) * passwordPolicy.AllowedSymbols.Length;

            return Math.Round((symbolCount / passwordLength), 3);
        }

		// Estimate the average number of symbols used to generate 
        // each password character where the password policy isn't known.
        private static double AverageSymbolsPerCharacter(string password)
        {
            double symbolCount = 0;
            List<bool> symbolFound = new List<bool>(password.Length);
 
            // Add to number of possible symbols for each character 
            // set included in the specified password.
            foreach (CharacterSet characterSet in CHARACTER_SETS.Values)
            {
                for (Int32 i = 0; i < password.Length; i++)
                {
                    if (characterSet.Characters.Contains(password[i].ToString()))
                    {
                        symbolCount += characterSet.Characters.Length;
                        symbolFound[i] = true;
                        break;
                    }
                }
            }

            // If any password characters weren't found, assume non-ASCII symbols included.
            if (symbolFound.Contains(false))
            {
                symbolCount += NON_ASCII_LENGTH;
            }

            return Math.Round((symbolCount / password.Length), 3);
        }

		/// <summary>
		/// Overrides the default ToString().
		/// </summary>
		/// <returns>
		/// The password entropy in bits. 
		/// </returns>
		public override string ToString()
		{
			return String.Concat("EntropyChecker: ", this.PasswordEntropy.ToString(CultureInfo.InvariantCulture));
		}
	}
}